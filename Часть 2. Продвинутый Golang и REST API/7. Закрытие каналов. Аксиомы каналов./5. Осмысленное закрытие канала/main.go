package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// Создали пункт передачи угля. Сразу после создания канал всегда открыт.
	transferPoint := make(chan int)

	go func() {
		// Получаем случайное число: либо 3 либо 4 либо 5 либо 6
		iterations := 3 + rand.Intn(4)
		fmt.Println("Количество найденного угля:", iterations)

		// Добываем весь случайно найденный уголь
		for i := 1; i <= iterations; i++ {
			// Иммитируем 300ms добычу очередной залежи угля
			time.Sleep(300 * time.Millisecond)

			// Передаём найденный уголь
			transferPoint <- 10
		}

		// Закрываем канал, благодаря чему сигнализируем читающим из этого канала горутинам, что новых осмысленных значений больше не будет в этом канале
		close(transferPoint)
	}()

	// Склад угля
	coal := 0

	for {
		// Ждём уголь в пункте передачи угля
		v, ok := <-transferPoint
		// Если переданное значение -- значение по умолчанию, значит канал закрыт
		// А если канал закрыт, значит запись в этот канал закончена
		// Если запись в этот канал закончена, значит нет смысла продолжать читать канал
		if !ok {
			fmt.Println("Шахтёр обработал всю шахту и добыл весь найденный там уголь!")
			break
		}

		// Если ok == true, значит v -- осмысленное переданное другой горутиной значение
		// Добавляем полученный уголь в склад угля
		coal += v

		// Выводим на каждой итерации значение переменной coal
		fmt.Println("coal:", coal)
	}

	/*
		// Тоже самое, что и в предыдущем цикле for, просто более красиво
		for v := range transferPoint {
			coal += v
			fmt.Println("coal:", coal)
		}

		fmt.Println("Шахтёр обработал всю шахту и добыл весь найденный там уголь!")
	*/

	fmt.Println("Суммарно добытый уголь:", coal)
}
